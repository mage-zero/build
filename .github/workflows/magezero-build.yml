name: MageZero Build

on:
  workflow_call:
    inputs:
      image_tag:
        description: Image tag or build identifier (used in artifact name).
        required: false
        default: ${{ github.sha }}
        type: string
      enable_promotions:
        description: "Enable same-run promotion jobs (staging/production). NOTE: without environment approvals this will auto-run."
        required: false
        default: false
        type: boolean
      setup_php:
        description: Install PHP tooling on the runner.
        required: false
        default: true
        type: boolean
      mz_control_url:
        description: Base URL for mz-control.
        required: true
        type: string
      build_command:
        description: Optional build command that replaces the default MageZero build.
        required: false
        default: ""
        type: string
      extra_build_command:
        description: Optional extra build steps to run before the default MageZero build.
        required: false
        default: ""
        type: string
      scd_locales:
        description: Optional space-separated locales to pass to setup:static-content:deploy (e.g. "en_US en_GB"). Empty means use Magento defaults.
        required: false
        default: ""
        type: string
      scd_themes:
        description: Optional space-separated themes to deploy static content for (e.g. "Vendor/theme Magento/backend"). Empty means all themes.
        required: false
        default: ""
        type: string
      scd_no_parent:
        description: Pass --no-parent to setup:static-content:deploy (useful for custom themes).
        required: false
        default: false
        type: boolean
      scd_jobs:
        description: Parallel jobs for setup:static-content:deploy (-j).
        required: false
        default: "2"
        type: string
    secrets:
      COMPOSER_AUTH:
        required: false

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      deploy_url: ${{ steps.creds.outputs.deploy_url }}
      php_version: ${{ steps.creds.outputs.php_version }}
      composer_version: ${{ steps.creds.outputs.composer_version }}
      artifact_name: ${{ steps.meta.outputs.artifact_name }}
      object_key: ${{ steps.meta.outputs.object_key }}
      promotion_targets_json: ${{ steps.creds.outputs.promotion_targets_json }}
      target_0_id: ${{ steps.creds.outputs.target_0_id }}
      target_0_type: ${{ steps.creds.outputs.target_0_type }}
      target_0_env: ${{ steps.creds.outputs.target_0_env }}
      target_1_id: ${{ steps.creds.outputs.target_1_id }}
      target_1_type: ${{ steps.creds.outputs.target_1_type }}
      target_1_env: ${{ steps.creds.outputs.target_1_env }}
      target_2_id: ${{ steps.creds.outputs.target_2_id }}
      target_2_type: ${{ steps.creds.outputs.target_2_type }}
      target_2_env: ${{ steps.creds.outputs.target_2_env }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build metadata
        id: meta
        run: |
          ARTIFACT_NAME="build-${GITHUB_REPOSITORY//\//-}-${IMAGE_TAG}.tar.zst"
          OBJECT_KEY="builds/${GITHUB_REPOSITORY}/${ARTIFACT_NAME}"
          echo "artifact_name=${ARTIFACT_NAME}" >> "${GITHUB_OUTPUT}"
          echo "object_key=${OBJECT_KEY}" >> "${GITHUB_OUTPUT}"
        env:
          IMAGE_TAG: ${{ inputs.image_tag }}

      - name: Request build targets
        id: creds
        run: |
          BASE_URL="${MZ_CONTROL_URL%/}"
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          PAYLOAD="{\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\"}"
          MAX_ATTEMPTS="${MZ_CONTEXT_MAX_ATTEMPTS:-5}"
          ATTEMPT=1
          while :; do
            RESPONSE="$(curl -sS -w "\n%{http_code}" -X POST "${BASE_URL}/v1/build/context" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "${PAYLOAD}" || printf '\n000')"
            RESPONSE_BODY="${RESPONSE%$'\n'*}"
            RESPONSE_CODE="${RESPONSE##*$'\n'}"

            if [ "${RESPONSE_CODE}" -lt 300 ]; then
              break
            fi

            if [ "${RESPONSE_CODE}" = "000" ] || [ "${RESPONSE_CODE}" = "429" ] || [ "${RESPONSE_CODE}" -ge 500 ]; then
              if [ "${ATTEMPT}" -lt "${MAX_ATTEMPTS}" ]; then
                SLEEP_SECONDS=$((ATTEMPT * 2))
                echo "mz-control transient error (${RESPONSE_CODE}) attempt ${ATTEMPT}/${MAX_ATTEMPTS}; retrying in ${SLEEP_SECONDS}s"
                sleep "${SLEEP_SECONDS}"
                ATTEMPT=$((ATTEMPT + 1))
                continue
              fi
            fi

            echo "mz-control error (${RESPONSE_CODE}): ${RESPONSE_BODY}"
            exit 1
          done

          DEPLOY_URL="$(printf '%s' "${RESPONSE_BODY}" | jq -r '.deploy_url // ""')"
          if [ -z "${DEPLOY_URL}" ] || [ "${DEPLOY_URL}" = "null" ]; then
            echo "mz-control error: missing deploy_url"
            exit 1
          fi
          echo "deploy_url=${DEPLOY_URL}" >> "${GITHUB_OUTPUT}"

          PHP_VERSION="$(printf '%s' "${RESPONSE_BODY}" | jq -r '.php_version // "8.2"')"
          echo "php_version=${PHP_VERSION}" >> "${GITHUB_OUTPUT}"

          COMPOSER_VERSION="$(printf '%s' "${RESPONSE_BODY}" | jq -r '.composer_version // "v2"')"
          echo "composer_version=${COMPOSER_VERSION}" >> "${GITHUB_OUTPUT}"

          PROMOTION_TARGETS="$(printf '%s' "${RESPONSE_BODY}" | jq -c '.promotion_targets // []')"
          echo "promotion_targets_json=${PROMOTION_TARGETS}" >> "${GITHUB_OUTPUT}"
          echo "Promotion targets: ${PROMOTION_TARGETS}"

          # Targets are ordered from lowest -> highest environment type.
          # Safety invariant: production MUST NEVER auto-deploy.
          TARGET_0_ID="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '[.[] | select((.environment_type // "" | ascii_downcase) != "production")][0].environment_id // empty')"
          TARGET_0_TYPE="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '[.[] | select((.environment_type // "" | ascii_downcase) != "production")][0].environment_type // empty')"
          TARGET_1_ID="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '.[1].environment_id // empty')"
          TARGET_1_TYPE="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '.[1].environment_type // empty')"
          TARGET_2_ID="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '.[2].environment_id // empty')"
          TARGET_2_TYPE="$(printf '%s' "${PROMOTION_TARGETS}" | jq -r '.[2].environment_type // empty')"

          if [ -z "${TARGET_0_ID}" ]; then
            # Defensive fallback: if promotion_targets isn't present/parseable, default to environment_id.
            TARGET_0_ID="$(printf '%s' "${RESPONSE_BODY}" | jq -r '.environment_id // empty')"
          fi
          if [ -z "${TARGET_0_ID}" ]; then
            echo "mz-control error: no eligible target environments for this repository/ref"
            exit 1
          fi

          to_github_env() {
            case "$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')" in
              non-production) printf '%s' "development" ;;
              performance) printf '%s' "staging" ;;
              production) printf '%s' "production" ;;
              *) printf '%s' "promotion" ;;
            esac
          }
          TARGET_0_ENV="$(to_github_env "${TARGET_0_TYPE}")"
          TARGET_1_ENV="$(to_github_env "${TARGET_1_TYPE}")"
          TARGET_2_ENV="$(to_github_env "${TARGET_2_TYPE}")"

          echo "target_0_id=${TARGET_0_ID}" >> "${GITHUB_OUTPUT}"
          echo "target_0_type=${TARGET_0_TYPE}" >> "${GITHUB_OUTPUT}"
          echo "target_0_env=${TARGET_0_ENV}" >> "${GITHUB_OUTPUT}"
          echo "target_1_id=${TARGET_1_ID}" >> "${GITHUB_OUTPUT}"
          echo "target_1_type=${TARGET_1_TYPE}" >> "${GITHUB_OUTPUT}"
          echo "target_1_env=${TARGET_1_ENV}" >> "${GITHUB_OUTPUT}"
          echo "target_2_id=${TARGET_2_ID}" >> "${GITHUB_OUTPUT}"
          echo "target_2_type=${TARGET_2_TYPE}" >> "${GITHUB_OUTPUT}"
          echo "target_2_env=${TARGET_2_ENV}" >> "${GITHUB_OUTPUT}"
        env:
          MZ_CONTROL_URL: ${{ inputs.mz_control_url }}

      - name: Summary
        run: |
          echo "### Eligible environments" >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "| Order | Env | Environment ID | Type | Name | Hostname |" >> "${GITHUB_STEP_SUMMARY}"
          echo "|---:|---|---:|---|---|---|" >> "${GITHUB_STEP_SUMMARY}"
          echo "${PROMOTION_TARGETS_JSON}" | jq -r 'to_entries[] | "| " + ((.key + 1) | tostring) + " | " + ( .value.environment_type // "" | ascii_downcase | (if . == "non-production" then "development" elif . == "performance" then "staging" elif . == "production" then "production" else . end) ) + " | " + ((.value.environment_id // "")|tostring) + " | " + ((.value.environment_type // "")|tostring) + " | " + ((.value.name // "")|tostring) + " | " + ((.value.hostname // "")|tostring) + " |"' >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "Auto deploy targets the first environment above." >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "This build run id (for promotions): ${GITHUB_RUN_ID}" >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "Same-run promotions are disabled by default (input: \`enable_promotions\`)." >> "${GITHUB_STEP_SUMMARY}"
          echo "If you enable promotions, you should gate them using environment approvals (GitHub Enterprise for private repos)." >> "${GITHUB_STEP_SUMMARY}"
        env:
          PROMOTION_TARGETS_JSON: ${{ steps.creds.outputs.promotion_targets_json }}

  create_build:
    name: Create Build
    runs-on: ubuntu-latest
    needs: prepare
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log PHP selection
        run: |
          echo "Requested PHP version: ${{ needs.prepare.outputs.php_version }}"

      - name: Log Composer selection
        run: |
          echo "Requested Composer version: ${{ needs.prepare.outputs.composer_version }}"

      - name: Setup PHP
        if: ${{ inputs.setup_php }}
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ needs.prepare.outputs.php_version }}
          extensions: rrd
          tools: composer:${{ needs.prepare.outputs.composer_version }}

      - name: Verify PHP
        if: ${{ inputs.setup_php }}
        run: php -v

      - name: Build Magento artifact
        run: |
          set -e
          if [ -f app/etc/config.php ]; then
            cp app/etc/config.php app/etc/config.php.bak
            trap 'mv app/etc/config.php.bak app/etc/config.php' EXIT
          fi
          php -r '
          $path = "app/etc/config.php";
          $config = file_exists($path) ? include $path : [];
          if (!is_array($config)) { $config = []; }
          if (!isset($config["scopes"])) {
            $config["scopes"] = [
              "websites" => [
                "admin" => [
                  "website_id" => "0",
                  "code" => "admin",
                  "name" => "Admin",
                  "sort_order" => "0",
                  "default_group_id" => "0",
                  "is_default" => "0",
                ],
                "base" => [
                  "website_id" => "1",
                  "code" => "base",
                  "name" => "Default",
                  "sort_order" => "0",
                  "default_group_id" => "1",
                  "is_default" => "1",
                ],
              ],
              "stores" => [
                "admin" => [
                  "store_id" => "0",
                  "code" => "admin",
                  "website_id" => "0",
                  "group_id" => "0",
                  "name" => "Admin",
                  "sort_order" => "0",
                  "is_active" => "1",
                ],
                "default" => [
                  "store_id" => "1",
                  "code" => "default",
                  "website_id" => "1",
                  "group_id" => "1",
                  "name" => "Default",
                  "sort_order" => "1",
                  "is_active" => "1",
                ],
              ],
              "groups" => [
                0 => [
                  "group_id" => "0",
                  "website_id" => "0",
                  "name" => "Admin",
                  "root_category_id" => "0",
                  "default_store_id" => "0",
                  "code" => "default",
                ],
                1 => [
                  "group_id" => "1",
                  "website_id" => "1",
                  "name" => "Default",
                  "root_category_id" => "1",
                  "default_store_id" => "1",
                  "code" => "default",
                ],
              ],
            ];
          }
          file_put_contents($path, "<?php\nreturn " . var_export($config, true) . ";\n");
          '
          if [ -n "${BUILD_COMMAND_OVERRIDE}" ]; then
            echo "Running build_command override."
            printf '%s\n' "${BUILD_COMMAND_OVERRIDE}" > /tmp/mz-build-override.sh
            . /tmp/mz-build-override.sh
            exit 0
          fi
          if [ -n "${EXTRA_BUILD_COMMAND}" ]; then
            echo "Running extra build steps."
            printf '%s\n' "${EXTRA_BUILD_COMMAND}" > /tmp/mz-extra-build.sh
            . /tmp/mz-extra-build.sh
          fi
          # Platform observability module (injected by MageZero)
          composer config repositories.magezero-opensearch-observability vcs https://github.com/mage-zero/magento2-opensearch-observability.git
          composer require mage-zero/magento2-opensearch-observability:1.0.2 --no-update
          php -r '
          $path = "app/etc/config.php";
          $config = file_exists($path) ? include $path : [];
          if (!is_array($config)) { $config = []; }
          if (!isset($config["modules"]) || !is_array($config["modules"])) { $config["modules"] = []; }
          $config["modules"]["MageZero_OpensearchObservability"] = 1;
          file_put_contents($path, "<?php\nreturn " . var_export($config, true) . ";\n");
          '
          composer install --no-dev --prefer-dist
          bin/magento setup:di:compile
          composer dump-autoload --optimize
          SCD_JOBS="${SCD_JOBS:-2}"
          SCD_LOCALES="${SCD_LOCALES:-}"
          SCD_THEMES="${SCD_THEMES:-}"
          SCD_NO_PARENT="${SCD_NO_PARENT:-false}"

          # Hard validation to prevent clients from injecting arbitrary CLI flags.
          # Only expose structured inputs: locales, themes, jobs, and explicit booleans.
          if ! printf '%s' "${SCD_JOBS}" | grep -Eq '^[0-9]+$'; then
            echo "Invalid SCD_JOBS: ${SCD_JOBS}"
            exit 1
          fi
          if [ "${SCD_JOBS}" -lt 1 ] || [ "${SCD_JOBS}" -gt 8 ]; then
            echo "SCD_JOBS out of range (1-8): ${SCD_JOBS}"
            exit 1
          fi

          locale_count=0
          if [ -n "${SCD_LOCALES}" ]; then
            for locale in ${SCD_LOCALES}; do
              locale_count=$((locale_count+1))
              if [ "${locale_count}" -gt 20 ]; then
                echo "Too many locales (max 20)."
                exit 1
              fi
              if ! printf '%s' "${locale}" | grep -Eq '^[A-Za-z]{2}_[A-Za-z]{2}$'; then
                echo "Invalid locale: ${locale}"
                exit 1
              fi
            done
          fi

          theme_count=0
          if [ -n "${SCD_THEMES}" ]; then
            for theme in ${SCD_THEMES}; do
              theme_count=$((theme_count+1))
              if [ "${theme_count}" -gt 20 ]; then
                echo "Too many themes (max 20)."
                exit 1
              fi
              if ! printf '%s' "${theme}" | grep -Eq '^[A-Za-z0-9_]+/[A-Za-z0-9_]+$'; then
                echo "Invalid theme: ${theme}"
                exit 1
              fi
            done
          fi

          scd_cmd=(bin/magento setup:static-content:deploy -f -j "${SCD_JOBS}")
          if [ "${SCD_NO_PARENT}" = "true" ]; then
            scd_cmd+=(--no-parent)
          fi
          if [ -n "${SCD_THEMES}" ]; then
            for theme in ${SCD_THEMES}; do
              scd_cmd+=(--theme "${theme}")
            done
          fi
          if [ -n "${SCD_LOCALES}" ]; then
            read -r -a scd_locales <<< "${SCD_LOCALES}"
            scd_cmd+=("${scd_locales[@]}")
          fi
          "${scd_cmd[@]}"

          # Guardrail: admin UI depends on pub/static/adminhtml being present in the artifact.
          test -d pub/static/adminhtml
        env:
          COMPOSER_AUTH: ${{ secrets.COMPOSER_AUTH }}
          BUILD_COMMAND_OVERRIDE: ${{ inputs.build_command }}
          EXTRA_BUILD_COMMAND: ${{ inputs.extra_build_command }}
          SCD_LOCALES: ${{ inputs.scd_locales }}
          SCD_THEMES: ${{ inputs.scd_themes }}
          SCD_NO_PARENT: ${{ inputs.scd_no_parent }}
          SCD_JOBS: ${{ inputs.scd_jobs }}

      - name: Generate OPcache preload file
        if: ${{ inputs.setup_php && inputs.build_command == '' }}
        run: |
          PRELOAD_PATH="app/opcache-preload.php"
          cat > /tmp/mz-opcache-preload-candidates.php <<'PHP'
          <?php
          $root = getcwd();
          $files = [];
          $shouldSkip = function (string $path): bool {
              $normalized = str_replace('\\', '/', strtolower($path));
              // Keep the preload list conservative. Anything that does not parse on the target PHP version
              // will crash PHP-FPM at startup (preload happens before userland try/catch can run).
              return strpos($normalized, '/test/') !== false
                  || strpos($normalized, '/tests/') !== false
                  || strpos($normalized, '/dev/') !== false
                  // Magento 2.4.x can carry legacy ZF1 code that is not PHP 8+ parse-safe. Exclude by default.
                  || strpos($normalized, '/vendor/magento/zendframework1/') !== false;
          };

          // 1) Composer "always-loaded" files.
          $autoloadFilesPath = $root . '/vendor/composer/autoload_files.php';
          if (is_file($autoloadFilesPath)) {
              $autoloadFiles = require $autoloadFilesPath;
              if (is_array($autoloadFiles)) {
                  foreach ($autoloadFiles as $path) {
                      if (!is_string($path) || $shouldSkip($path)) {
                          continue;
                      }
                      $files[] = $path;
                  }
              }
          }

          // 2) Concrete classes referenced by compiled DI metadata.
          $autoloadPath = $root . '/vendor/autoload.php';
          $loader = is_file($autoloadPath) ? (require $autoloadPath) : null;
          $findFile = function (string $fqcn) use ($loader): ?string {
              if (!$loader || !is_object($loader) || !method_exists($loader, 'findFile')) {
                  return null;
              }
              $path = $loader->findFile($fqcn);
              return is_string($path) && $path !== '' ? $path : null;
          };

          $metadataRoot = $root . '/generated/metadata';
          if (is_dir($metadataRoot)) {
              $iterator = new RecursiveIteratorIterator(
                  new RecursiveDirectoryIterator($metadataRoot, FilesystemIterator::SKIP_DOTS)
              );
              foreach ($iterator as $file) {
                  if (!$file->isFile() || $file->getExtension() !== 'php') {
                      continue;
                  }
                  $metaPath = $file->getPathname();
                  if ($shouldSkip($metaPath)) {
                      continue;
                  }
                  $config = require $metaPath;
                  if (!is_array($config)) {
                      continue;
                  }

                  // Preferences: interface => concrete class
                  foreach (($config['preferences'] ?? []) as $concrete) {
                      if (!is_string($concrete) || $concrete === '') {
                          continue;
                      }
                      $path = $findFile($concrete);
                      if ($path && !$shouldSkip($path)) {
                          $files[] = $path;
                      }
                  }

                  // Instance types: virtual types => concrete classes
                  foreach (($config['instanceTypes'] ?? []) as $type => $_info) {
                      if (!is_string($type) || $type === '') {
                          continue;
                      }
                      $path = $findFile($type);
                      if ($path && !$shouldSkip($path)) {
                          $files[] = $path;
                      }
                  }
              }
          }

          // 3) Generated code (factories/interceptors/proxies) tends to be a high-signal preload target.
          $generatedCode = $root . '/generated/code';
          if (is_dir($generatedCode)) {
              $iterator = new RecursiveIteratorIterator(
                  new RecursiveDirectoryIterator($generatedCode, FilesystemIterator::SKIP_DOTS)
              );
              foreach ($iterator as $file) {
                  if ($file->isFile() && $file->getExtension() === 'php') {
                      $pathName = $file->getPathname();
                      if ($shouldSkip($pathName)) {
                          continue;
                      }
                      $files[] = $pathName;
                  }
              }
          }

          $files = array_values(array_unique(array_filter($files, 'is_string')));
          sort($files);

          foreach ($files as $file) {
              $real = realpath($file);
              if ($real === false || $shouldSkip($real)) {
                  continue;
              }
              echo $real . PHP_EOL;
          }
          PHP

          # Candidate list (absolute paths)
          php /tmp/mz-opcache-preload-candidates.php > /tmp/mz-opcache-preload.candidates.txt || true

          # Filter candidates to only files that parse on this build's PHP version.
          # Preload cannot recover from parse errors, so we must exclude them.
          # Uses token_get_all(TOKEN_PARSE) in a single process instead of forking
          # php -l per file, reducing lint time from minutes to seconds.
          cat > /tmp/mz-opcache-lint.php <<'LINTPHP'
          <?php
          $input  = '/tmp/mz-opcache-preload.candidates.txt';
          $output = '/tmp/mz-opcache-preload.ok.txt';
          if (!is_file($input)) { file_put_contents($output, ''); exit(0); }
          $candidates = file($input, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
          $ok = [];
          $skipped = 0;
          foreach ($candidates as $file) {
              $file = trim($file);
              if ($file === '' || !is_file($file)) { continue; }
              try {
                  token_get_all(file_get_contents($file), TOKEN_PARSE);
                  $ok[] = $file;
              } catch (\ParseError $e) {
                  $skipped++;
                  fwrite(STDERR, "Skipping (parse error): {$file}: {$e->getMessage()}\n");
              }
          }
          file_put_contents($output, implode(PHP_EOL, $ok) . ($ok ? PHP_EOL : ''));
          fwrite(STDERR, count($ok) . " files passed lint, {$skipped} skipped.\n");
          LINTPHP
          php /tmp/mz-opcache-lint.php || true

          # Emit preload file using repo-relative paths.
          php -r '
            $root = getcwd();
            $preloadPath = $root . "/app/opcache-preload.php";
            $okList = "/tmp/mz-opcache-preload.ok.txt";
            $rootPrefix = rtrim($root, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
            $files = [];
            if (is_file($okList)) {
              $lines = file($okList, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) ?: [];
              foreach ($lines as $abs) {
                $abs = trim((string)$abs);
                if ($abs === "" || strpos($abs, $rootPrefix) !== 0) { continue; }
                $rel = substr($abs, strlen($rootPrefix));
                if ($rel === "app/opcache-preload.php") { continue; }
                $files[$rel] = true;
              }
            }
            ksort($files);
            $lines = [
              "<?php",
              "// Generated at build time. Do not edit.",
              "if (!function_exists(\"opcache_compile_file\")) { return; }",
              "\$root = dirname(__DIR__);",
              "\$files = " . var_export(array_keys($files), true) . ";",
              "foreach (\$files as \$file) {",
              "    \$path = \$root . \"/\" . \$file;",
              "    if (is_file(\$path)) {",
              "        @opcache_compile_file(\$path);",
              "    }",
              "}",
              "",
            ];
            if (!is_dir(dirname($preloadPath))) { mkdir(dirname($preloadPath), 0775, true); }
            file_put_contents($preloadPath, implode(PHP_EOL, $lines));
          ' || true

          if [ ! -s "${PRELOAD_PATH}" ]; then
            echo "<?php return;" > "${PRELOAD_PATH}"
          fi
          echo "OPcache preload file: ${PRELOAD_PATH}"

      - name: Build artifact
        run: |
          ARTIFACT_NAME="${ARTIFACT_NAME}"
          ARTIFACT_PATH="/tmp/${ARTIFACT_NAME}"
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> "${GITHUB_ENV}"
          echo "ARTIFACT_PATH=${ARTIFACT_PATH}" >> "${GITHUB_ENV}"
          tar -I 'zstd -10 -T0' -cf "${ARTIFACT_PATH}" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='var/cache' \
            --exclude='var/page_cache' \
            .
        env:
          ARTIFACT_NAME: ${{ needs.prepare.outputs.artifact_name }}

      - name: Upload artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: magezero-build-${{ github.run_id }}
          path: ${{ env.ARTIFACT_PATH }}
          if-no-files-found: error

  deploy_auto:
    name: Build/Deploy (${{ needs.prepare.outputs.target_0_env }})
    runs-on: ubuntu-latest
    needs: [prepare, create_build]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: magezero-build-${{ github.run_id }}
          path: /tmp

      - name: Request upload URL
        id: presign
        run: |
          BASE_URL="${MZ_CONTROL_URL%/}"
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          RESPONSE="$(curl -sS -w "\n%{http_code}" -X POST "${BASE_URL}/v1/build/presign" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID},\"object_key\":\"${OBJECT_KEY}\",\"bucket\":\"backups\",\"method\":\"PUT\",\"expires_in\":1800}")"
          RESPONSE_BODY="${RESPONSE%$'\n'*}"
          RESPONSE_CODE="${RESPONSE##*$'\n'}"
          if [ "${RESPONSE_CODE}" -ge 300 ]; then
            echo "mz-control error (${RESPONSE_CODE}): ${RESPONSE_BODY}"
            exit 1
          fi
          UPLOAD_URL="$(echo "${RESPONSE_BODY}" | jq -r '.url')"
          if [ -z "${UPLOAD_URL}" ] || [ "${UPLOAD_URL}" = "null" ]; then
            echo "mz-control error: missing upload URL"
            exit 1
          fi
          echo "::add-mask::${UPLOAD_URL}"
          echo "upload_url=${UPLOAD_URL}" >> "${GITHUB_OUTPUT}"
        env:
          MZ_CONTROL_URL: ${{ inputs.mz_control_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_0_id }}

      - name: Upload artifact to R2
        run: |
          ARTIFACT_PATH="/tmp/${ARTIFACT_NAME}"
          if [ ! -f "${ARTIFACT_PATH}" ]; then
            echo "Build artifact not found: ${ARTIFACT_PATH}"
            ls -la /tmp || true
            exit 1
          fi
          curl -fsS -X PUT --upload-file "${ARTIFACT_PATH}" "${UPLOAD_URL}"
        env:
          ARTIFACT_NAME: ${{ needs.prepare.outputs.artifact_name }}
          UPLOAD_URL: ${{ steps.presign.outputs.upload_url }}

      - name: Trigger deployment
        if: ${{ needs.prepare.outputs.deploy_url != '' }}
        run: |
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          curl -fsS -X POST "${DEPLOY_URL}" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"artifact\":\"${OBJECT_KEY}\",\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID}}"
        env:
          DEPLOY_URL: ${{ needs.prepare.outputs.deploy_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_0_id }}

  promote_1:
    name: Build/Deploy (${{ needs.prepare.outputs.target_1_env }})
    runs-on: ubuntu-latest
    needs: [prepare, create_build, deploy_auto]
    if: ${{ inputs.enable_promotions && needs.prepare.outputs.target_1_id != '' }}
    environment: ${{ needs.prepare.outputs.target_1_env }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: magezero-build-${{ github.run_id }}
          path: /tmp

      - name: Request upload URL
        id: presign
        run: |
          BASE_URL="${MZ_CONTROL_URL%/}"
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          RESPONSE="$(curl -sS -w "\n%{http_code}" -X POST "${BASE_URL}/v1/build/presign" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID},\"object_key\":\"${OBJECT_KEY}\",\"bucket\":\"backups\",\"method\":\"PUT\",\"expires_in\":1800}")"
          RESPONSE_BODY="${RESPONSE%$'\n'*}"
          RESPONSE_CODE="${RESPONSE##*$'\n'}"
          if [ "${RESPONSE_CODE}" -ge 300 ]; then
            echo "mz-control error (${RESPONSE_CODE}): ${RESPONSE_BODY}"
            exit 1
          fi
          UPLOAD_URL="$(echo "${RESPONSE_BODY}" | jq -r '.url')"
          if [ -z "${UPLOAD_URL}" ] || [ "${UPLOAD_URL}" = "null" ]; then
            echo "mz-control error: missing upload URL"
            exit 1
          fi
          echo "::add-mask::${UPLOAD_URL}"
          echo "upload_url=${UPLOAD_URL}" >> "${GITHUB_OUTPUT}"
        env:
          MZ_CONTROL_URL: ${{ inputs.mz_control_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_1_id }}

      - name: Upload artifact to R2
        run: |
          ARTIFACT_PATH="/tmp/${ARTIFACT_NAME}"
          if [ ! -f "${ARTIFACT_PATH}" ]; then
            echo "Build artifact not found: ${ARTIFACT_PATH}"
            ls -la /tmp || true
            exit 1
          fi
          curl -fsS -X PUT --upload-file "${ARTIFACT_PATH}" "${UPLOAD_URL}"
        env:
          ARTIFACT_NAME: ${{ needs.prepare.outputs.artifact_name }}
          UPLOAD_URL: ${{ steps.presign.outputs.upload_url }}

      - name: Trigger deployment
        run: |
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          curl -fsS -X POST "${DEPLOY_URL}" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"artifact\":\"${OBJECT_KEY}\",\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID}}"
        env:
          DEPLOY_URL: ${{ needs.prepare.outputs.deploy_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_1_id }}

  promote_2:
    name: Build/Deploy (${{ needs.prepare.outputs.target_2_env }})
    runs-on: ubuntu-latest
    needs: [prepare, create_build, promote_1]
    if: ${{ inputs.enable_promotions && needs.prepare.outputs.target_2_id != '' }}
    environment: ${{ needs.prepare.outputs.target_2_env }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: magezero-build-${{ github.run_id }}
          path: /tmp

      - name: Request upload URL
        id: presign
        run: |
          BASE_URL="${MZ_CONTROL_URL%/}"
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          RESPONSE="$(curl -sS -w "\n%{http_code}" -X POST "${BASE_URL}/v1/build/presign" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID},\"object_key\":\"${OBJECT_KEY}\",\"bucket\":\"backups\",\"method\":\"PUT\",\"expires_in\":1800}")"
          RESPONSE_BODY="${RESPONSE%$'\n'*}"
          RESPONSE_CODE="${RESPONSE##*$'\n'}"
          if [ "${RESPONSE_CODE}" -ge 300 ]; then
            echo "mz-control error (${RESPONSE_CODE}): ${RESPONSE_BODY}"
            exit 1
          fi
          UPLOAD_URL="$(echo "${RESPONSE_BODY}" | jq -r '.url')"
          if [ -z "${UPLOAD_URL}" ] || [ "${UPLOAD_URL}" = "null" ]; then
            echo "mz-control error: missing upload URL"
            exit 1
          fi
          echo "::add-mask::${UPLOAD_URL}"
          echo "upload_url=${UPLOAD_URL}" >> "${GITHUB_OUTPUT}"
        env:
          MZ_CONTROL_URL: ${{ inputs.mz_control_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_2_id }}

      - name: Upload artifact to R2
        run: |
          ARTIFACT_PATH="/tmp/${ARTIFACT_NAME}"
          if [ ! -f "${ARTIFACT_PATH}" ]; then
            echo "Build artifact not found: ${ARTIFACT_PATH}"
            ls -la /tmp || true
            exit 1
          fi
          curl -fsS -X PUT --upload-file "${ARTIFACT_PATH}" "${UPLOAD_URL}"
        env:
          ARTIFACT_NAME: ${{ needs.prepare.outputs.artifact_name }}
          UPLOAD_URL: ${{ steps.presign.outputs.upload_url }}

      - name: Trigger deployment
        run: |
          TOKEN="$(curl -fsS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=mz-control" \
            -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')"
          curl -fsS -X POST "${DEPLOY_URL}" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"artifact\":\"${OBJECT_KEY}\",\"repository\":\"${GITHUB_REPOSITORY}\",\"ref\":\"${GITHUB_REF}\",\"environment_id\":${TARGET_ENV_ID}}"
        env:
          DEPLOY_URL: ${{ needs.prepare.outputs.deploy_url }}
          OBJECT_KEY: ${{ needs.prepare.outputs.object_key }}
          TARGET_ENV_ID: ${{ needs.prepare.outputs.target_2_id }}
